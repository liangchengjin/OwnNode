<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <title>原型的继承</title>
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <!--css-->
  <style>
  *{margin:0; padding:0;}
  body{font-family: "Hiragino Sans GB","Microsoft Yahei",arial,\5b8b\4f53,"Helvetica Neue",Helvetica,STHeiTi,sans-serif;}
  
  </style>
 </head>
 <body>
  
	
  
  <!--js-->
  <script>
  /*
	#div1.__proto__ ->HTMLDivElement.prototype->HTMLElement.prototype->Element.prototype->Node.prototopy->EventTarget.prototpe->Object.prototype

	*/

	// 模拟 Object 继承
		/*
		function Object(){
			
		}
		Object.prototype = {
			constructor:Object,
			hasOwnProperty: function(){
				
			}
		}

		function EventTarget(){
			
		}

		// 继承
		myEventTarget.prototype = new myObject();
		myEventTarget.prototype.addEventListener = function(){
		
		}

		function myNode(){
		
		}
		// 继承
			myNode.prototype = new myEventTarget;
			myNode.prototype.createElement = function(){
			
			};
			
			var n = new myNode;
		*/

	// 2. 原型的继承方法
			function A(){
				this.x = 100;
			}
			A.prototype.getX = function(){
				console.log(this.x);
			}
			function B(){
				this.y = 200;
			}
			B.prototype = new A;
			B.prototype.constructor = B;

			// ->"原型继承" 是我们js中最常用的一个种继承方式
			// ->子类B想要继承父类A中的所有的属性和方法(私有+公有)，只要让B.prototype = new A; 即可
			// ->原型继承的特点：它是把父类中私有的+公有的都继承到了子类原型上(子有的)

	
	// 3. 核心：原型继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是让B和A之间增加了原型链的连接，以后B的实例n想要中A中的getX方法，需要一级级的向上查找来使用。
  </script>
 </body>
</html>
