<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="own">
  <title>标题</title>
  <meta name="Keywords" content="关键词,关键词">
  <meta name="Description" content="描述">
  
 <style type="text/css">
	html,body,ul,li{margin:0; padding:0;font-size:14px; font-family:"微软雅黑"; list-style:none;}
	#list{margin:10px auto 0; padding:10px; width:80%; border:1px solid #ddd; border-radius:10px; background:-webkit-linear-gradient(top left,#660099,#67b168,#ff0066);}
	#list li{ padding:5px; cursor:pointer;}
	.c1{background:#ddd;}
	.c2{background:#ffcc00;}
	
 </style>
 </head>
 <body>
	<div id="list">
		<ul>
			<li>前端模块化开发的价值</li>
			<li>随着互联网的飞速发展，前端开发越来越复杂。本文将从实际项目中遇到的问题出发，讲述模块化能解决哪些问题，以及如何使用 Sea.js 进行前端的模块化开发。</li>
			<li>我们从一个简单的习惯出发。我做项目时，常常会将一些通用的、底层的功能抽象出来，独立成一个个函数，比如</li>
			<li>并像模像样地把这些函数统一放在 util.js 里。需要用到时，引入该文件就行。这一切工作得很好，同事也很感激我提供了这么便利的工具包。</li>
			<li>抱怨越来越多。团队经过一番激烈的讨论，决定参照 Java 的方式，引入命名空间来解决。于是 util.js 里的代码变成了</li>
			<li>不要认为上面的代码是为了写这篇文章而故意捏造的。将命名空间的概念在前端中发扬光大，首推 Yahoo! 的 YUI2 项目。下面是一段真实代码，来自 Yahoo! 的一个开源项目。</li>
			<li>通过命名空间，的确能极大缓解冲突。但每每看到上面的代码，都忍不住充满同情。为了调用一个简单的方法，需要记住如此长的命名空间，这增加了记忆负担，同时剥夺了不少编码的乐趣。</li>
			<li>作为前端业界的标杆，YUI 团队下定决心解决这一问题。在 YUI3 项目中，引入了一种新的命名空间机制。</li>
			<li>前端模块化开发的价值</li>
			<li>随着互联网的飞速发展，前端开发越来越复杂。本文将从实际项目中遇到的问题出发，讲述模块化能解决哪些问题，以及如何使用 Sea.js 进行前端的模块化开发。</li>
			<li>我们从一个简单的习惯出发。我做项目时，常常会将一些通用的、底层的功能抽象出来，独立成一个个函数，比如</li>
			<li>并像模像样地把这些函数统一放在 util.js 里。需要用到时，引入该文件就行。这一切工作得很好，同事也很感激我提供了这么便利的工具包。</li>
			<li>抱怨越来越多。团队经过一番激烈的讨论，决定参照 Java 的方式，引入命名空间来解决。于是 util.js 里的代码变成了</li>
			<li>不要认为上面的代码是为了写这篇文章而故意捏造的。将命名空间的概念在前端中发扬光大，首推 Yahoo! 的 YUI2 项目。下面是一段真实代码，来自 Yahoo! 的一个开源项目。</li>
			<li>通过命名空间，的确能极大缓解冲突。但每每看到上面的代码，都忍不住充满同情。为了调用一个简单的方法，需要记住如此长的命名空间，这增加了记忆负担，同时剥夺了不少编码的乐趣。</li>
			<li>作为前端业界的标杆，YUI 团队下定决心解决这一问题。在 YUI3 项目中，引入了一种新的命名空间机制。</li>			
		</ul>	
	</div>
  
  <script>
  // 1. 原理：操作所有的li, 让按照奇偶行的规律，改变他的class样式的属性值，奇娄行是c1，偶数行是c2

  // 2. 通过元素的标签名获取一组元素
   document.getElementsByTagName("元素的标签名");
	 /*
	   在整个文档中(获取的范围, 上下文), 我们通过元素的标签名(div、li、p...)来获取一组元素	   
	 */

	
  // 3. 获取整个文档中所有的li, 他是一个集合, 我们把这个集合叫做类数组(类似数组), 并且类数组是对象娄数据类型的。
  //var oLis = document.getElementsByTagName("li");
		
	 /*
	    console.log(oLis);
		索引(属性名)：就是代表当前是第几个元素的位置下标，索引是从0开始的，索引为0代表第一个li，索引为1代表第二个li...索引为n+1个li

		length: 代表获取的集合的长度，或者是当前获取了对少个Li

		console.log(oLis.length);
		console.log(oLis["length"]);
		
		oLis[0];
		console.log(oLis[0]); // 获取某一个指定的元素的oLis[索引]

		oLis.item(0);
		通过DOM方法获取的类数组还可以用 .item(索引) 来获取某一个
		console.log(oLis.item(0)); 
	 */
	 
	 var oList = document.getElementById("list");
	 var oLis = oList.getElementsByTagName("li");
	 for(var i = 0; i < oLis.length; i++){
		// i = 0; 第一次循环 获取第一个 li oLis[0]
		// i = 1; 第二次循环 获取第二个 li oLis[1]

		var oLi = oLis[i]; // 每一次循环的时候 在类数组中把对应的li 取出来
		
			/*i = 0; 偶数	第一行 奇数行
			i = 1; 奇数 第二行 偶数行
			i的值是偶数代表奇数行, i 的值是奇数代表偶数行

			i%2 i除以为2取数*/
		
		 i%2===0?oLi.className = "c1":oLi.className = "c2";
		// oLi.style.backgroundColor = "";
		//oLi.className = "c1"; // 设置每一个li的class样式的属性的值

	 }


	  

	  
  
  
  </script>
 </body>
</html>
