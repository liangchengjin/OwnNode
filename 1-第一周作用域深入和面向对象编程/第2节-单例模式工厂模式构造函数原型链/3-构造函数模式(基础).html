<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>构造函数模式(基础)</title>
</head>
<body>


<script>
    // TODO:构造函数模式(基础)

        // 这是我们的工厂模式
           /* function createJsPerson(name, age){
             var obj = {};
             obj.name = name;
             obj.age = age;
             obj.writeJs = function(){
             console.log("my name is" + this.name+ ", i can write js 啦~~~");
             };
             return obj;
             }

             var p1 = new createJsPerson("小明", 16);
             p1.writeJs();  // my name is小明, i can write js 啦~~~*/


    // TODO:一、构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例
        /**
         * 构造函数模式和工厂模式的区别？
         *  1.执行的时候
         *      普通函数执行-->createJsPerson();         *
         *
         *      a. 构造函数模式-->new createJsPerson(); 通过new执行后，我们的CreateJsPerson就是一个类了，为什么要大写呢。就是为了让用户一看到这个就是一个类。这只是一个约定的习惯
         *
         *      b. 而函数执行的返回值(p1)就是CreateJsPerson这个类的一个实例
         *
         *
         *  2.在函数代码执行的时候
         *
         *      a. 相同点：都是开成一个私有的作用域，然后进行形参赋值--预解释-->代码从上到下执行(类和普通函数一样，它也有普通的一面)
         *
         *      b. 不同点：在代码执行之前，不用自己在手动的创建对象了，浏览器会默认的创建一个对象数据类型的值(这个对象其实就是我们当前类的一个实例)
         *
         *
         *      接下来代码从上到下执行，以当前的实例为执行的主体(this代表的就是当前的实例)，然后分别的把属性名和属性赋值给当前的实例
         *
         *      最后浏览器会默认的把创建的实例返回
         */

             function CreateJsPerson(name, age){
                    // 浏览器默认的创建的对象就是我们的实例 p1 -->就是这个 this
                    this.name = name;
                    this.age = age;
                    this.writeJs = function(){
                        console.log("my name is" + this.name+ ", i can write js 啦~~~");
                    };
                    // 在这里浏览器把创建的实例默认的进行返回
             }

             var p1 = new CreateJsPerson("小明", 16);
             p1.writeJs();  // my name is小明, i can write js 啦~~~  CreateJsPerson -->this

             var p2 = new CreateJsPerson("梁成",22);
             p2.writeJs();  // my name is梁成, i can write js 啦~~~

            console.log(p1 == p2);

            // 这一种就是普通函数执行，主要就是看它的函数里有没有return 如果没有 就是 undefined
            var res = CreateJsPerson("深圳", 80); // 这个函数里的this是谁？ 是 window ; 这样写不是构造函数模式执行而是普通的函数执行，由于没有写return所以 res=undefined 并且CreateJsPerson这个方法中的this就是window
            console.log(res);  // undefined







    // TODO:三、创建一个数组有两种方法
            /**
             * var ary = [];  // 这种就是字面量方式
             * var ary = new Array(); // 实例创建的方式-->构造函数模式执行的方式
             * 不一种方式ary都是Array这个类的一个实例
             *
             * 重点1：
             *      js中所的类都是函数数据类型的，它通过new执行变成了一个类，但是它本身也是一个普通的函数
             *
             *         js当中所有的实例都是对象数据类型的。
             *
             * 重点2：
             *      第四个this: 在构造函数模式当中,类中(函数体中)出现的this.xxx.xxx中的this就是当前类的一个实例
             *
             *
             *
             * 重点3：
             *     p1和p2都是CreateJsPerson这个类的实例，所以都拥有writeJs这个方法，但是不同实例之间的方法是不一样的
             *
             *     在类中实例增加的属性(this.xxx=xxx) 属于当前实例的私有的属性，实例和实例之间是单独的个体，所以私有的属性之间是不相等的。
             *
             *
             *    提示：面试问题的问题
             *          1.面试官 认为我们的前面的对象模式，不是单例模式，因为他们只是用台后开发的语言去理解，那时错的
             *              他们以为构造函数模式才是单例模式，这也错的理解，
             *
             *              单例模式就是一个破对象的创建方式成一个 个体手工创建，
             *              工厂模式就是把实现同一件事情的相同的代码放到一个函数中，以后如果在想实现这个功能，不需要从新的编写这些代码了，只需要执行当前的函数即可-->工厂模式它有一个专业的名词它叫"函数的封装"
             *
             */
             console.log(p1.writeJs === p2.writeJs); // -->false


//33:56






























</script>
</body>
</html>